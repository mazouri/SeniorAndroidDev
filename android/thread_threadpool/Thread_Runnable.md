# Thread和Runnable

## Thread和Runnable的区别？

Thread是多个线程分别完成自己的任务，Runnable是多个线程共同完成一个任务。

[Java中Runnable和Thread区别](http://blog.csdn.net/uudou/article/details/51841781)

[Java中继承thread类与实现Runnable接口的区别](http://mars914.iteye.com/blog/1508429)

## start()方法与run()方法区别？

[Thread的run（）与start（）的区别](http://blog.csdn.net/xuxurui007/article/details/7685076)

调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。
- start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程
- run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。
> **多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发**

## 同一个Thread线程，调用多次start方法，会产生多少个线程？

一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果只有一个线程。  

## 线程的五种状态
- 创建状态：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态
- 就绪状态：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态
- 运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码
- 阻塞状态：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
- 死亡状态：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪

## Sleep ()、suspend ()和 wait ()之间有什么区别？

sleep ()使当前线程在指定的时间处于“非运行”（Not Runnable）状态。线程一直持有对象的监视器。比如一个线程当前在一个同步块或同步方法中，其它线程不能进入该块或方法中。如果另一线程调用了 interrupt ()方法，它将唤醒那个“睡眠的”线程。
注意：sleep ()是一个静态方法。这意味着只对当前线程有效，一个常见的错误是调用t.sleep ()，（这里的t是一个不同于当前线程的线程）。即便是执行t.sleep ()，也是当前线程进入睡眠，而不是t线程。

suspend ()是过时的方法，使用 suspend ()导致线程进入停滞状态，该线程会一直持有对象的监视器，suspend ()容易引起死锁问题。

wait ()使当前线程出于“不可运行”状态，和 sleep ()不同的是wait 是 object 的方法而不是 thread。调用 object.wait ()时，线程先要获取这个对象的对象锁，当前线程必须在锁对象保持同步，把当前线程添加到等待队列中，随后另一线程可以同步同一个对象锁来调用 object.notify ()，这样将唤醒原来等待中的线程，然后释放该锁。基本上wait ()/notify ()与 sleep ()/interrupt ()类似，只是前者需要获取对象锁。

[wait方法和sleep方法的区别](http://www.cnblogs.com/bethunebtj/p/5696999.html)









