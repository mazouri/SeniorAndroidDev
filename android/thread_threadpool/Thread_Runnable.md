# Thread和Runnable

## Thread和Runnable的区别？

Thread是多个线程分别完成自己的任务，Runnable是多个线程共同完成一个任务。

[Java中Runnable和Thread区别](http://blog.csdn.net/uudou/article/details/51841781)

[Java中继承thread类与实现Runnable接口的区别](http://mars914.iteye.com/blog/1508429)

## start()方法与run()方法区别？

[Thread的run（）与start（）的区别](http://blog.csdn.net/xuxurui007/article/details/7685076)

调用start（）后，线程会被放到等待队列，等待CPU调度，并不一定要马上开始执行，只是将这个线程置于可动行状态。然后通过JVM，线程Thread会调用run（）方法，执行本线程的线程体。先调用start后调用run，这么麻烦，为了不直接调用run？就是为了实现多线程的优点，没这个start不行。
- start（）方法来启动线程，真正实现了多线程运行。这时无需等待run方法体代码执行完毕，可以直接继续执行下面的代码；通过调用Thread类的start()方法来启动一个线程， 这时此线程是处于就绪状态， 并没有运行。 然后通过此Thread类调用方法run()来完成其运行操作的， 这里方法run()称为线程体，它包含了要执行的这个线程的内容， Run方法运行结束， 此线程终止。然后CPU再调度其它线程
- run（）方法当作普通方法的方式调用。程序还是要顺序执行，要等待run方法体执行完毕后，才可继续执行下面的代码； 程序中只有主线程——这一个线程， 其程序执行路径还是只有一条， 这样就没有达到写线程的目的。
> **多线程就是分时利用CPU，宏观上让所有线程一起执行 ，也叫并发**

## 同一个Thread线程，调用多次start方法，会产生多少个线程？

一个线程对象只能启动一个线程，无论你调用多少遍start()方法，结果只有一个线程。  

## 线程的五种状态
- 创建状态：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态
- 就绪状态：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态
- 运行状态：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码
- 阻塞状态：线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。
- 死亡状态：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪















