# 链表问题汇总

# 链表定义
> 链表(单链表)实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。
> 而向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。

> 节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。


1.[链表长度](https://github.com/mazouri/SeniorAndroidDev/blob/master/algorithm_datastructure/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md#链表长度)

2.得到链表倒数第k个节点的值 
3.删除链表的倒数第k个节点
4.求单链表的中间节点
5.判断链表是否有环
6.找出有环链表的环的入口
7.判断两个单链表是否相交
8.找出两个相交链表的第一个交点
9.从尾到头打印单链表
10.逆置单链表
11.合并两个有序链表，使合并后的链表依然有序
12.在o(1)的时间复杂度删除单链表中指定的某一节点
13.链表成对交换节点
14.无序链表排序
15.链表首尾交叉排序

# 链表的代码表示
```
class ListNode  
{   int value;  //存储的内容
    ListNode next;   //对下一个节点的引用
    public ListNode(int value)  
    {  
        this.value=value;  
        this.next=null;  
    }  
}  
```
# 链表长度
方法一：
- 头节点为null，则长度为0；否则至少有一个
- 如果下一个节点的引用不为空，则长度自增，head引用指向下一个节点；while循环判断直到没有下一个节点
- 返回长度
```
    public static int getLen(ListNode head)  
    {  
        if(head==null) 
            return 0;  
        int len=1;  
        while(head.next!=null)  
        {  
            len++;  
            head=head.next;  
        }  
        return len;  
    }  
```
方法二：
> 递归
- 先判断头节点是否为null
- 不为空，则加上查询下一个节点的长度；递归直到head为null
```
    public static int getLenRec(ListNode head)  
    {  
        if(head==null)   
            return 0;  
         return getLenRec(head.next)+1;  
    } 
```
# 得到链表倒数第k个节点的值  
思路：因为倒数第k个和最后一个相距k-1个节点，故采用前后指针，第一个先走k-1步，即走到第k个,(链表我习惯从1开始计算)然后两个指针在同时走，当前指针p走到末尾时，后指针q的位置刚好是倒数第k个节点
```
    /**
     * 
     * List:       **********************
     * p先K步：     ***
     * 
     * p\q再同时走：**********************
     *            *******************
     *            
     * 类似于，我和你同时走一个100m的跑到，你先走30m，
     * 然后咱两再一起走，等你到终点的时候，我离终点还有30m
     * 这样也就确定了终点倒数30m的位置了
     * 
     * @param head
     * @param k
     * @return
     */
    public static int getLastK(ListNode head, int k) {
        if (head == null || k <= 0)
            return -1;
        ListNode p = head; //辅助链表
        ListNode q = head; //取值链表
        while (--k > 0)//让p先走k-1步，即p走到第k个节点，从1开始计数哈~
        {
            p = p.next;
            if (p.next == null)
                break;  //防止输入的倒数k值特别大的异常情况
        }
        if (p.next == null)//说明输入的k超出链表长度范围or等于链表长度，即删除第一个。一定要特别注意这些特别情况，代码的鲁棒性~~
        {
            return head.value;
        } else {
            while (p.next != null) {
                p = p.next;
                q = q.next;
            }
            return q.value;
        }
    }
```
# 删除链表的倒数第k个节点
思路：和上面相比就是要删除倒数第k个，那么就需要记录后指针的前一节点，因为删除链表的本质就是它的前一节点指向它的后一节点 
```
    /**
     * 思路：和上面相比就是要删除倒数第k个，那么就需要记录后指针的前一节点，因为删除链表的本质就是它的前一节点指向它的后一节点
     */
    public static ListNode removeLastK(ListNode head, int k) {
        if (head == null || k <= 0)
            return null;
        ListNode p = head;
        ListNode q = head;
        while (--k > 0)//让p先走k-1步，即p走到第k个节点，从1开始计数哈~
        {
            p = p.next;
            if (p.next == null)
                break;  //防止输入的倒数k值特别大的异常情况
        }
        if (p.next == null)//说明输入的k超出链表长度范围or等于链表长度，即删除第一个。
        {
            return head.next;
        } else {
            ListNode pre = q;//用于记录删除节点的前一节点
            while (p.next != null) {
                pre = q;
                p = p.next;
                q = q.next;
            }
            pre.next = q.next;
            return head;
        }
    }
```
# 求单链表的中间节点
```
    /**
     * 链表为null或者只有一个节点时，没有中间节点
     * 若链表有两个节点时，返回第一个节点
     *
     * 前后指针，一个每次走2步一个每次走1步，若链表长度为奇数返回中间值，为偶数返回中间2者的前一者
     */
    public static int getMid(ListNode head) {
        if (head == null || head.next == null)//0个节点和1个节点时
            return -1;
        if (head.next.next == null)//两个节点时
            return head.value;
        ListNode p = head;
        ListNode q = head;
        while (p.next != null && p.next.next != null)//若只有 一个节点 和 两个节点 时while条件不满足
        {
            p = p.next.next;
            q = q.next;
        }
        return q.value;
    }
```
# 判断链表是否有环
http://www.cnblogs.com/kqingchao/archive/2011/07/06/whether_there_is_a_loop_in_link.html
```
    /**
     * 思路：前后指针，一个每次走两步一个每次走一步，若两指针相遇了则说明链表有环
     */
    public static boolean isHaveC(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) //只有两个节点时也无环吧？
            return false;
        ListNode p = head;
        ListNode q = head;
        while (p.next != null && p.next.next != null) {
            p = p.next.next;
            q = q.next;
            if (p == q)
                return true;
        }
        return false;
    }
```
# 找出有环链表的环的入口
```
    /**
     * 找出有环链表的环的入口
     *
     * 思路：若有环肯定会在环中相遇第一次相遇的位置到环开始的位置的距离（按环的方向）与头节点到环的开始的距离相等。
     * 故当相遇时，让节点q（slow）置于头节点，让后两个节点同时走，再次相遇处就是环开始的位置。
     *
     * 证明：走一步的指针叫slow，走两步的叫fast；相遇的时候，slow共移动了s步，fast共移动了2s步，这个是显而易见的。
     *      a：链表头移动a步到达入口点
     *      x：入口点移动x步到达相遇点
     *      r：环的周长
     *      t：从相遇点移动到入口点的移动步数
     *      L：从链表头移动L步，又到达了相遇点。也就是遍历完链表之后，通过最后一个节点的指针，又移动到了链表中的相遇点
     *
     *      那么，Ｌ　＝　a + r  =  a + x + t
     *      那么slow和fast相遇了，fast必然比slow多走了n个圈，也就是 n*r 步，那么，
     *          (1)s = a + x
     *          (2)2s = s + n*r --> s = n*r
     *      把（1）带入（2）式中得，a+x = n*r = (n-1)*r + r
     *      从表头移动到入口点，再从入口点移动到入口点，也就是移动了整个链表的距离，即是 L =  a + r , 所以r = L - a
     *      所以 a+x = (n-1)*r + L - a ,   于是 a = (n-1)*r + L - a - x = (n-1)*r + t
     *
     * @param head
     * @return
     */
    public static ListNode getFirstC(ListNode head) {
        if (head == null || head.next == null || head.next.next == null)
            return null;
        ListNode p = head;
        ListNode q = head;
        while (p.next != null && p.next.next != null) {
            p = p.next.next;
            q = q.next;
            if (p == q)
                break;  //pq相遇后break
        }
        if (p.next == null || p.next.next == null)//无环
            return null;
        q = head;//把q置于头节点
        while (p != q) {
            p = p.next;
            q = q.next;
        }
        return q;
    }
```
# 判断两个单链表是否相交
```
    /**
     * 思路：若两链表相交，则两链表的尾节点肯定是同一节点(如果是头尾相连，就是一个链表了)
     */
    public boolean isXJ(ListNode head1, ListNode head2) {
        if (head1 == null || head2 == null)
            return false;

        ListNode tail1 = head1;
        while (tail1.next != null)//不包含只有一个节点的情况 ,所以上面需要考虑只有一个节点的情况，但是此时虽只有一个节点都不进入入while,就return时比较就可以了
        {
            tail1 = tail1.next;//得到head1的尾巴
        }
        ListNode tail2 = head2;
        while (tail2.next != null) {
            tail2 = tail2.next;
        }
        return tail1 == tail2;
    }
```
# 找出两个相交链表的第一个交点
```
    /**
     * 思路:先让长的链表的指针先走长度差的距离，然后两个指针一起走，相遇的地方便是交点的开始处。
     */
    public static ListNode getFirstJD(ListNode head1, ListNode head2) {
        if (head1 == null || head2 == null)
            return null;

        //计算链表1的长度
        ListNode tail1 = head1;
        int len1 = 1;
        while (tail1.next != null) {
            len1++;
            tail1 = tail1.next;
        }
        //计算链表2的长度
        ListNode tail2 = head2;
        int len2 = 1;
        while (tail2.next != null) {
            len2++;
            tail2 = tail2.next;
        }

        //长的链表的指针先走长度差的距离
        ListNode n1 = head1;
        ListNode n2 = head2;
        if (len1 > len2) {
            int k = len1 - len2;
            while (k-- > 0)//这样写更精妙~~~~
                n1 = n1.next;
        } else {
            int k = len2 - len1;
            while (k-- > 0)
                n2 = n2.next;
        }
        while (n1 != n2) {
            n1 = n1.next;
            n2 = n2.next;
        }
        return n1;
    }
```

