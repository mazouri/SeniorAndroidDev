# 链表问题汇总

# 链表定义
> 链表(单链表)实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。
> 而向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。

> 节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。


1.[链表长度](https://github.com/mazouri/SeniorAndroidDev/blob/master/algorithm_datastructure/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB.md#链表长度)

2.得到链表倒数第k个节点的值 
3.删除链表的倒数第k个节点
4.求单链表的中间节点
5.判断链表是否有环
6.找出有环链表的环的入口
7.判断两个单链表是否相交
8.找出两个相交链表的第一个交点
9.从尾到头打印单链表
10.逆置单链表
11.合并两个有序链表，使合并后的链表依然有序
12.在o(1)的时间复杂度删除单链表中指定的某一节点
13.链表成对交换节点
14.无序链表排序
15.链表首尾交叉排序

# 链表的代码表示
```
class ListNode  
{   int value;  //存储的内容
    ListNode next;   //对下一个节点的引用
    public ListNode(int value)  
    {  
        this.value=value;  
        this.next=null;  
    }  
}  
```
# 链表长度
方法一：
- 头节点为null，则长度为0；否则至少有一个
- 如果下一个节点的引用不为空，则长度自增，head引用指向下一个节点；while循环判断直到没有下一个节点
- 返回长度
```
    public static int getLen(ListNode head)  
    {  
        if(head==null) 
            return 0;  
        int len=1;  
        while(head.next!=null)  
        {  
            len++;  
            head=head.next;  
        }  
        return len;  
    }  
```
方法二：
> 递归
- 先判断头节点是否为null
- 不为空，则加上查询下一个节点的长度；递归直到head为null
```
    public static int getLenRec(ListNode head)  
    {  
        if(head==null)   
            return 0;  
         return getLenRec(head.next)+1;  
    } 
```
# 得到链表倒数第k个节点的值  
思路：因为倒数第k个和最后一个相距k-1个节点，故采用前后指针，第一个先走k-1步，即走到第k个,(链表我习惯从1开始计算)然后两个指针在同时走，当前指针p走到末尾时，后指针q的位置刚好是倒数第k个节点
```
    /**
     * 
     * List:       **********************
     * p先K步：     ***
     * 
     * p\q再同时走：**********************
     *            *******************
     *            
     * 类似于，我和你同时走一个100m的跑到，你先走30m，
     * 然后咱两再一起走，等你到终点的时候，我离终点还有30m
     * 这样也就确定了终点倒数30m的位置了
     * 
     * @param head
     * @param k
     * @return
     */
    public static int getLastK(ListNode head, int k) {
        if (head == null || k <= 0)
            return -1;
        ListNode p = head; //辅助链表
        ListNode q = head; //取值链表
        while (--k > 0)//让p先走k-1步，即p走到第k个节点，从1开始计数哈~
        {
            p = p.next;
            if (p.next == null)
                break;  //防止输入的倒数k值特别大的异常情况
        }
        if (p.next == null)//说明输入的k超出链表长度范围or等于链表长度，即删除第一个。一定要特别注意这些特别情况，代码的鲁棒性~~
        {
            return head.value;
        } else {
            while (p.next != null) {
                p = p.next;
                q = q.next;
            }
            return q.value;
        }
    }
```
# 删除链表的倒数第k个节点
思路：和上面相比就是要删除倒数第k个，那么就需要记录后指针的前一节点，因为删除链表的本质就是它的前一节点指向它的后一节点 
```
    /**
     * 思路：和上面相比就是要删除倒数第k个，那么就需要记录后指针的前一节点，因为删除链表的本质就是它的前一节点指向它的后一节点
     */
    public static ListNode removeLastK(ListNode head, int k) {
        if (head == null || k <= 0)
            return null;
        ListNode p = head;
        ListNode q = head;
        while (--k > 0)//让p先走k-1步，即p走到第k个节点，从1开始计数哈~
        {
            p = p.next;
            if (p.next == null)
                break;  //防止输入的倒数k值特别大的异常情况
        }
        if (p.next == null)//说明输入的k超出链表长度范围or等于链表长度，即删除第一个。
        {
            return head.next;
        } else {
            ListNode pre = q;//用于记录删除节点的前一节点
            while (p.next != null) {
                pre = q;
                p = p.next;
                q = q.next;
            }
            pre.next = q.next;
            return head;
        }
    }
```
# 求单链表的中间节点
```
    /**
     * 链表为null或者只有一个节点时，没有中间节点
     * 若链表有两个节点时，返回第一个节点
     *
     * 前后指针，一个每次走2步一个每次走1步，若链表长度为奇数返回中间值，为偶数返回中间2者的前一者
     */
    public static int getMid(ListNode head) {
        if (head == null || head.next == null)//0个节点和1个节点时
            return -1;
        if (head.next.next == null)//两个节点时
            return head.value;
        ListNode p = head;
        ListNode q = head;
        while (p.next != null && p.next.next != null)//若只有 一个节点 和 两个节点 时while条件不满足
        {
            p = p.next.next;
            q = q.next;
        }
        return q.value;
    }
```
# 判断链表是否有环
http://www.cnblogs.com/kqingchao/archive/2011/07/06/whether_there_is_a_loop_in_link.html
```
    /**
     * 思路：前后指针，一个每次走两步一个每次走一步，若两指针相遇了则说明链表有环
     */
    public static boolean isHaveC(ListNode head) {
        if (head == null || head.next == null || head.next.next == null) //只有两个节点时也无环吧？
            return false;
        ListNode p = head;
        ListNode q = head;
        while (p.next != null && p.next.next != null) {
            p = p.next.next;
            q = q.next;
            if (p == q)
                return true;
        }
        return false;
    }
```
# 找出有环链表的环的入口



