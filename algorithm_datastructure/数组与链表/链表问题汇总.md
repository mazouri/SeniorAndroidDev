# 链表问题汇总

# 链表定义
> 链表(单链表)实际上是由节点（Node）组成的，一个链表拥有不定数量的节点。
> 而向外暴露的只有一个头节点（Head），我们对链表的所有操作，都是直接或者间接地通过其头节点来进行的。

> 节点（Node）是由一个需要储存的对象及对下一个节点的引用组成的。也就是说，节点拥有两个成员：储存的对象、对下一个节点的引用。


1.[链表长度](https://github.com/mazouri/SeniorAndroidDev/tree/master/algorithm_datastructure/数组与链表/#链表长度)

2.得到链表倒数第k个节点的值 
3.删除链表的倒数第k个节点
4.求单链表的中间节点
5.判断链表是否有环
6.找出有环链表的环的入口
7.判断两个单链表是否相交
8.找出两个相交链表的第一个交点
9.从尾到头打印单链表
10.逆置单链表
11.合并两个有序链表，使合并后的链表依然有序
12.在o(1)的时间复杂度删除单链表中指定的某一节点
13.链表成对交换节点
14.无序链表排序
15.链表首尾交叉排序

# 链表的代码表示
```
class ListNode  
{   int value;  //存储的内容
    ListNode next;   //对下一个节点的引用
    public ListNode(int value)  
    {  
        this.value=value;  
        this.next=null;  
    }  
}  
```
# 链表长度
方法一：
- 头节点为null，则长度为0；否则至少有一个
- 如果下一个节点的引用不为空，则长度自增，head引用指向下一个节点；while循环判断直到没有下一个节点
- 返回长度
```
    public static int getLen(ListNode head)  
    {  
        if(head==null) 
            return 0;  
        int len=1;  
        while(head.next!=null)  
        {  
            len++;  
            head=head.next;  
        }  
        return len;  
    }  
```
方法二：
> 递归
- 先判断头节点是否为null
- 不为空，则加上查询下一个节点的长度；递归直到head为null
```
    public static int getLenRec(ListNode head)  
    {  
        if(head==null)   
            return 0;  
         return getLenRec(head.next)+1;  
    } 
```




